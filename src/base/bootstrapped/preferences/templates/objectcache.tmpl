{!

    /* BRN: this file currently will not work in Google Chrome because WebSQL cannot be synchronous */

    /**
     *    Template for the object cache tab in the preferences menu
     *
     */
    var cachedObjects = [];

    libx.storage.metacacheStore.async = false;
    libx.storage.metacacheStore.find({
        success: function(filepaths) {
            var fetchedFiles = 0;
            filepaths.forEach(function (filepath) {
                /* get the metadata */
                libx.storage.metacacheStore.getItem({
                    key: filepath,
                    success: function(text) {
                        var metadata = libx.utils.json.parse(text);
                        /* Calculate the name of the file, this is used to sort */
                        var urlparts = filepath.split ( '/' );
                        var name = urlparts[urlparts.length - 1].length > 0 
                            ? urlparts[urlparts.length - 1] : urlparts[urlparts.length - 2];
                        try {
                            cachedObjects.push ( {
                                url : filepath,
                                lastmod : metadata.lastModified,
                                mimetype : metadata.mimeType,
                                name : name
                            } );
                        } catch (e) {
                            libx.log.write("objectcache.tmpl: invalid metadata for " + filepath);
                            cachedObjects.push({
                                url: filepath,
                                name: name
                            });
                        }
                        cachedObjects.sort( function ( a, b ) { 
                            return a.name > b.name; 
                        } );
                    }
                });
            });
        }
    });
    
!}

{DefaultLocale=en_US}
{BeginLocale=en_US}
    {
        "flushcache_button" :   { "message" : "Flush Global Memory Cache" },
        "purgeall_button" :     { "message" : "Purge All" },
        "refresh_button" :      { "message" : "Refresh" },
        "opencachedcopy" :      { "message" : "(Open Cached Copy)" },
        "purge" :               { "message" : "(Purge)" },
        "mimetype" :            { "message" : "Mime-Type:" }
    }
{EndLocale}

<div id="objectcache-content" style="font-size:.8em;">
    <div id="actions">
        <button id="link-flush">{L "flushcache_button" L}</button>
        <button id="link-purgeall">{L "purgeall_button" L}</button>
        <button id="link-refresh">{L "refresh_button" L}</button>
    </div>
    <br/>
    <div class="accordion" style="overflow:scroll;height:400px">
        <for each="obj" in="cachedObjects">
            <div class="ui-dialog-titlebar">
                <h3>
                    <a href="#">
                        <if test="obj.lastmod != null">
                            <label style="float:right">{+obj.lastmod+}</label>
                        </if>
                        <label>{+obj.url+}</label>
                    </a>
                </h3>
                <div class="ui-widget-content">
                    <a class="link-opencache" href="#{+obj.url+}" data-mimetype="{+obj.mimetype+}" target="_blank">{L "opencachedcopy" L}</a>
                    <a href="#{+obj.url+}" class="purgebutton" style="float:right"> {L "purge" L}</a>
                    <p>{L "mimetype" L} {+ obj.mimetype +} </p>	
                </div>
            </div>
        </for>
    </div>
</div>

<script type="text/javascript">

$('#actions').buttonset();

$(".accordion").accordion({ header: "h3" });

$('.accordion > div > span').click(function() {
    $(this).next().toggle();
}).next().hide();

$('.purgebutton').click(function() {
    var filename = $(this).attr('href').substr(1);
    libx.storage.cacheStore.removeItem({
        key: filename,
        success: function () {
            libx.storage.metacacheStore.removeItem({
                key: filename,
                success: function () {
                    $("#link-refresh").click();
                }
            });
        }
    });
    return false;
});

$('#link-flush').click(function() {
    libx.cache.defaultMemoryCache.flush();
});

$('#link-purgeall').click(function() {
    libx.storage.cacheStore.clear({
        success: function () {
            libx.storage.metacacheStore.clear({
                success: function () {
                    $("#link-refresh").click();
                }
            });
        }
    });
});

$('#link-refresh').click(function() {
    var aQueues = [];
    $("#objectcache-content").replaceWith( process( aQueues, null, "objectcache" ) );
    aQueues[0].markReady();
});

$('.link-opencache').each(function(i, elem) {
    var filename = $(this).attr('href').substr(1);
    libx.storage.cacheStore.getItem( {
        key: filename,
        success: function (text) {
            if(text.substr(0, 5) != 'data:')
                text = 'data:' + $(elem).attr('data-mimetype') + ';base64,' + libx.utils.binary.binary2Base64(text);
            $(elem).attr('href', text);
        }
    } );
});
    
</script>
